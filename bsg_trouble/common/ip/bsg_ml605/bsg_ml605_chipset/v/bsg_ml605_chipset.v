//------------------------------------------------------------
// University of California, San Diego - Bespoke Systems Group
//------------------------------------------------------------
// File: bsg_ml605_chipset.v
//
// Author: Luis Vega - lvgutierrez@eng.ucsd.edu
//------------------------------------------------------------

`include "raw_tn_packet_s.sv" // for port_tn_sif
`include "port_link.v" // for port3_sif

module bsg_ml605_chipset
  (input clk_i
  // resets
  ,input reset_i
  ,output uncore_reset_o
  // done
  ,output boot_done_o
  // pcie in
  ,input [5:0] pcie_valid_i
  ,input [31:0] pcie_data_i [5:0]
  ,output [5:0] pcie_yumi_o
  // pcie out
  ,output [5:0] pcie_valid_o
  ,output [31:0] pcie_data_o [5:0]
  ,input [5:0] pcie_ready_i
  // dram in
  ,input dram_valid_i
  ,input [31:0] dram_data_i
  ,output dram_thanks_o
  // dram out
  ,output dram_valid_o
  ,output [31:0] dram_data_o
  ,input dram_thanks_i
  // fmc in
  ,input fmc_valid_i
  ,input [79:0] fmc_data_i
  ,output fmc_ready_o
  // fmc out
  ,output fmc_valid_o
  ,output [79:0] fmc_data_o
  ,input fmc_ready_i);

  // fsb node signal

  logic [1:0] fsb_node_reset_lo;
  logic [1:0] fsb_node_en_lo;

  logic [1:0] fsb_node_valid_lo;
  logic [79:0] fsb_node_data_lo [1:0];
  logic [1:0] fsb_node_ready_li;

  logic [1:0] fsb_node_valid_li;
  logic [79:0] fsb_node_data_li [1:0];
  logic [1:0] fsb_node_yumi_lo;

  // uncore reset

  assign uncore_reset_o = fsb_node_reset_lo[0];

  // fsb node[0]: virtual tile array for pcie and dram

  // chipset gateway (pcie/dram <---> vta)

  port3_sif converter_south_lo, vta_south_lo;
  port3_sif converter_west_lo, vta_west_lo;
  port_tn_sif converter_tn_lo[0:0], vta_tn_lo[0:0];

  bsg_ml605_chipset_vta_converter converter
    (.clk_i(clk_i)
    ,.reset_i(fsb_node_reset_lo[0])
    // pcie in
    ,.pcie_valid_i(pcie_valid_i)
    ,.pcie_data_i(pcie_data_i)
    ,.pcie_yumi_o(pcie_yumi_o)
    // pcie out
    ,.pcie_valid_o(pcie_valid_o)
    ,.pcie_data_o(pcie_data_o)
    ,.pcie_ready_i(pcie_ready_i)
    // dram in
    ,.dram_valid_i(dram_valid_i)
    ,.dram_data_i(dram_data_i)
    ,.dram_thanks_o(dram_thanks_o)
    // dram out
    ,.dram_valid_o(dram_valid_o)
    ,.dram_data_o(dram_data_o)
    ,.dram_thanks_i(dram_thanks_i)
    // vta south
    ,.vta_south_i(vta_south_lo)
    ,.vta_south_o(converter_south_lo)
    // vta west
    ,.vta_west_i(vta_west_lo)
    ,.vta_west_o(converter_west_lo)
    // vta test network
    ,.vta_tn_i(vta_tn_lo[0])
    ,.vta_tn_o(converter_tn_lo[0]));

  // vta

  logic tr_done_lo;

  logic switch_2_blockValid;
  logic [79:0] switch_2_blockData [0:0];
  logic switch_2_blockRetry;

  logic block_2_switchValid;
  logic [79:0] block_2_switchData [0:0];
  logic block_2_switchRetry;

  virtual_tile_array #
    (.COLLECT_MASK(4'b0111) // --> CHECK
    ,.tile_x_max_p(1)
    ,.tile_y_max_p(1)
    ,.bsg_style_p (1'b1))
  vta
    (.clk(clk_i)
    ,.reset_ext(fsb_node_reset_lo[0])
    // vta south - trace <-> south[0] and dram <-> south[1]
    ,.southwest_south_in(converter_south_lo)
    ,.southwest_south_out(vta_south_lo)
    // vta west
    ,.southwest_west_in(converter_west_lo)
    ,.southwest_west_out(vta_west_lo)
    // vta test network
    ,.port_tn_edge_i(converter_tn_lo)
    ,.port_tn_edge_o(vta_tn_lo)
    // murn ctrl
    ,.powerup()
    ,.reset_bdiom(fsb_node_reset_lo[0])
    ,.enabled(tr_done_lo)
    // murn in
    ,.switch_2_blockValid(switch_2_blockValid)
    ,.switch_2_block(switch_2_blockData)
    ,.switch_2_blockRetry(switch_2_blockRetry)
    // murn out
    ,.block_2_switchValid(block_2_switchValid)
    ,.block_2_switch(block_2_switchData)
    ,.block_2_switchRetry(block_2_switchRetry));

  bsg_murn_converter #
    (.nodes_p(1)
    ,.ring_width_p(80))
  bmc
    (.clk_i(clk_i)
    ,.reset_i(fsb_node_reset_lo[0])
    // vta in
    ,.block_2_switchValid(block_2_switchValid) // I
    ,.block_2_switchData(block_2_switchData)   // I
    ,.block_2_switchRetry(block_2_switchRetry) // O
    // vta out
    ,.switch_2_blockValid(switch_2_blockValid) // O
    ,.switch_2_blockData(switch_2_blockData)   // O
    ,.switch_2_blockRetry(switch_2_blockRetry) // I
    // fsb in
    ,.v_i(fsb_node_valid_lo[0])
    ,.data_i(fsb_node_data_lo[0:0])
    ,.ready_o(fsb_node_ready_li[0])
    // fsb out
    ,.v_o(fsb_node_valid_li[0])
    ,.data_o(fsb_node_data_li[0:0])
    ,.yumi_i(fsb_node_yumi_lo[0]));

  // fsb node[1]: rom for booting bsg_asic

  logic [5:0] tr_rom_addr_lo;
  logic [83:0] rom_data_lo;

  // this module is generated by bsg_ascii_to_rom.py using
  // bsg_fpga/ip/bsg_ml605/bsg_ml605_chipset/trace/boot.trace
  bsg_ml605_chipset_rom #
    (.width_p(84)
    ,.addr_width_p(6))
  rom
    (.addr_i(tr_rom_addr_lo)
    ,.data_o(rom_data_lo));

  bsg_fsb_node_trace_replay #
    (.ring_width_p(80)
    ,.rom_addr_width_p(6))
  tr
    (.clk_i(clk_i)
    ,.reset_i(fsb_node_reset_lo[1])
    ,.en_i(fsb_node_en_lo[1])
    // in
    ,.v_i(fsb_node_valid_lo[1])
    ,.data_i(fsb_node_data_lo[1])
    ,.ready_o(fsb_node_ready_li[1])
    // out
    ,.v_o(fsb_node_valid_li[1])
    ,.data_o(fsb_node_data_li[1])
    ,.yumi_i(fsb_node_yumi_lo[1])
    // rom
    ,.rom_addr_o(tr_rom_addr_lo)
    ,.rom_data_i(rom_data_lo)
    ,.done_o(tr_done_lo)
    ,.error_o());

  assign boot_done_o = tr_done_lo;

  // fsb - two nodes
  // ---------------
  // node[0]: virtual tile array (vta)
  // node[1]: bsg_asic boot rom (rom + tr)

  logic btf_valid_lo;
  logic [79:0] btf_data_lo;
  logic fsb_asm_yumi_lo;

  bsg_fsb #
    (.width_p(80)
    ,.nodes_p(2)
    ,.enabled_at_start_vec_p(2'b11)
    ,.snoop_vec_p(2'b00))
  fsb
    (.clk_i(clk_i)
    ,.reset_i(reset_i)
    // node ctrl
    ,.node_reset_r_o(fsb_node_reset_lo)
    ,.node_en_r_o(fsb_node_en_lo)
    // node in
    ,.node_v_i(fsb_node_valid_li)
    ,.node_data_i(fsb_node_data_li)
    ,.node_yumi_o(fsb_node_yumi_lo)
    // node out
    ,.node_v_o(fsb_node_valid_lo)
    ,.node_data_o(fsb_node_data_lo)
    ,.node_ready_i(fsb_node_ready_li)
    // asm in
    ,.asm_v_i(btf_valid_lo)
    ,.asm_data_i(btf_data_lo)
    ,.asm_yumi_o(fsb_asm_yumi_lo)
    // asm out
    ,.asm_v_o(fmc_valid_o)
    ,.asm_data_o(fmc_data_o)
    ,.asm_ready_i(fmc_ready_i));

  // yumi to ready flow-control conversion

  bsg_two_fifo #
    (.width_p(80))
  btf
    (.clk_i(clk_i)
    ,.reset_i(reset_i)
    // in
    ,.v_i(fmc_valid_i)
    ,.data_i(fmc_data_i)
    ,.ready_o(fmc_ready_o)
    // out
    ,.v_o(btf_valid_lo)
    ,.data_o(btf_data_lo)
    ,.yumi_i(fsb_asm_yumi_lo));

endmodule
